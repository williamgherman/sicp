### Exercise 1.20.
The process that a procedure generates is of course dependent on the rules used
by the interpreter. As an example, consider the iterative `gcd` procedure given
above. Suppose we were to interpret this procedure using normal-order
evaluation, as discussed in section 1.1.5. (The normal-order-evaluation rule for
`if` is described in exercise 1.5.) Using the substitution method (for normal
order), illustrate the process generated in evaluating `(gcd 206 40)` and
indicate the `remainder` operations that are actually performed. How many
`remainder` operations are actually performed in the normal-order evaluation of
`(gcd 206 40)`? In the applicative-order evaluation?

### Solution
Below is the process for `gcd` written in the text:
```scheme
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
```
and the process generated by `(gcd 206 40)` in normal order:
```scheme
(gcd 206 40)
(gcd 40 (remainder 206 40)
(if (= 6 0) ...) ; +1
(gcd (remainder 206 40) (remainder 40 (remainder 206 40))) 
(if (= 4 0) ...) ; +2
(gcd (remainder 40 (remainder 206 40)) 
     (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))
(if (= 2 0) ...) ; +4
(gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
     (remainder (remainder 40 (remainder 206 40)))
                (remainder (remainder 206 40)
                           (remainder 40 (remainder 206 40))))
(if (= 0 0) ...) ; +7
(remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
2                ; +4
```
totaling in 18 `remainder` operations, opposed to the below process generated by
`(gcd 206 40)` in applicative order:
```scheme
(gcd 206 40)
(gcd 40 (remainder 206 40))
(gcd 40 6) ; +1
(gcd 6 (remainder 40 6))
(gcd 6 4)  ; +1
(gcd 4 (remainder 6 4))
(gcd 4 2)  ; +1
(gcd 2 (remainder 4 2))
(gcd 2 0)  ; +1
2
```
which evaluates only 4 `remainder` operations.
